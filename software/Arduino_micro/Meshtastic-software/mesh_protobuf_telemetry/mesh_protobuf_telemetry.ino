/*
test mestastic decode message
compiled in an arduino uno
10822 flash bytes (33%) of 32256 bytes.
674 RAM bytes (32%)
nanopb-0.4.9.1-windows-x86
https://jpa.kapsi.fi/nanopb/download/
files list in
C:\Users\myname\Documents\Arduino\libraries\Nanopb
pb.h
pb_common.c
pb_common.h
pb_decode.c
pb_decode.h
pb_encode.c
pb_encode.h
--------------
https://github.com/meshtastic/firmware/tree/master/src/mesh/generated/meshtastic (Generated by nanopb-0.4.9.1)
files list in the project directory: (with path meshtastic/ removed in *.cpp and mesh.pb.h files)
mesh.ino
channel.pb.cpp
channel.pb.h
config.pb.cpp
config.pb.h
device_ui.pb.cpp
device_ui.pb.h
mesh.pb.cpp
mesh.pb.h
module_config.pb.cpp
module_config.pb.h
portnums.pb.cpp
portnums.pb.h
telemetry.pb.cpp
telemetry.pb.h
xmodem.pb.cpp
xmodem.pb.h
---------------
https://protobuf-decoder.netlify.app/
test it
complete payload main frame
08 43 12 18 0d ab 18 ad 67 12 11 08 65 15 b0 72 88 40 1d 93 5f fc 3f 25 a6 c1 31 3f
telemetry payload frame sub part for main frame
0D AB 18 AD 67 12 11 08 65 15 B0 72 88 40 1D 93 5F FC 3F 25 A6 C1 31 3F 
Results in the serial monitor:

Decoded test_number: 67
message length : 24
0D AB 18 AD 67 12 11 08 65 15 B0 72 88 40 1D 93 5F FC 3F 25 A6 C1 31 3F 
Time stamp: 1739397291
Variant number: 2
Is deviceMetrics:
Battery Level: 101
Voltage: 4.26
Channel Utilization: 1.97
Air Utilization TX: 0.69
*/

#include "mesh.pb.h"
#include "pb_common.h"
#include "pb.h"
//#include "pb_encode.h"
#include "pb_decode.h"

/// helper function for decoding a record as a protobuf, we will return false if the decoding failed
bool pb_decode_from_bytes(const uint8_t *srcbuf, size_t srcbufsize, const pb_msgdesc_t *fields, void *dest_struct) {
  pb_istream_t stream = pb_istream_from_buffer(srcbuf, srcbufsize);
  if (!pb_decode(&stream, fields, dest_struct)) {
    char buf[100];
    sprintf("Can't decode protobuf reason='%s', pb_msgdesc %p", PB_GET_ERROR(&stream), fields);
    Serial.println(buf);
    return false;
  } else {
    return true;
  }
}

void printBuf(char *buf, int len) {
  int i;
  Serial.print("message length : ");
  Serial.println(len);
  for (i = 0; i < len; i++) {
    if ((unsigned char)buf[i] < 16) {
      Serial.print("0");
    }
    Serial.print((unsigned char)buf[i], HEX);
    Serial.print(" ");
  }

  Serial.println();
}

void setup() {

  Serial.begin(115200);
  //telemetry payload
  uint8_t buffer[] = { 0x08, 0x43, 0x12, 0x18, 0x0D, 0xAB, 0x18, 0xAD, 0x67, 0x12, 0x11, 0x08, 0x65, 0x15, 0xB0, 0x72, 0x88, 0x40, 0x1D, 0x93, 0x5F, 0xFC, 0x3F, 0x25, 0xA6, 0xC1, 0x31, 0x3F };  //telemetry message
  meshtastic_Data decoded_message meshtastic_Data_init_zero;
  bool status;

  status = pb_decode_from_bytes(buffer, sizeof(buffer), meshtastic_Data_fields, &decoded_message);

  if (!status) {
    Serial.println("Failed to decode");
    return;
  }

  Serial.print("Decoded test_number: ");
  Serial.println(decoded_message.portnum);

  meshtastic_Data_payload_t payload = decoded_message.payload;
  char *buf = malloc(payload.size);          // because of terminating `\0`
  memcpy(buf, payload.bytes, payload.size);  // copy the message
  printBuf(buf, payload.size);
  if (decoded_message.portnum == 67) {  //telemetry
    meshtastic_Telemetry scratch;
    meshtastic_Telemetry *decoded = NULL;
    memset(&scratch, 0, sizeof(scratch));
    if (pb_decode_from_bytes(payload.bytes, payload.size, &meshtastic_Telemetry_msg, &scratch)) {
      decoded = &scratch;
      Serial.print(F("Time stamp: "));
      Serial.println(decoded->time);
      Serial.print(F("Variant number: "));
      Serial.println(decoded->which_variant);
      if (decoded->which_variant == 2) {  // Le variant est DeviceMetrics
        meshtastic_DeviceMetrics *metrics = &(decoded->variant.device_metrics);
        Serial.println(F("Is deviceMetrics:"));
        if (metrics->has_battery_level) {
          Serial.print(F("Battery Level: "));
          Serial.println(metrics->battery_level);
        }

        if (metrics->has_voltage) {
          Serial.print(F("Voltage: "));
          Serial.println(metrics->voltage);
        }

        if (metrics->has_channel_utilization) {
          Serial.print(F("Channel Utilization: "));
          Serial.println(metrics->channel_utilization);
        }

        if (metrics->has_air_util_tx) {
          Serial.print(F("Air Utilization TX: "));
          Serial.println(metrics->air_util_tx);
        }

        if (metrics->has_uptime_seconds) {
          Serial.print(F("Uptime Seconds: "));
          Serial.println(metrics->uptime_seconds);
        }
      }

      if (decoded->which_variant == 3) {  // Le variant est EnvironmentMetrics
        meshtastic_EnvironmentMetrics *env_metrics = &(decoded->variant.environment_metrics);
        Serial.println(F("Is environmentMetrics:"));
        if (env_metrics->has_temperature) {
          Serial.print(F("Temperature: "));
          Serial.println(env_metrics->temperature);
        }

        if (env_metrics->has_relative_humidity) {
          Serial.print(F("Relative Humidity: "));
          Serial.println(env_metrics->relative_humidity);
        }

        if (env_metrics->has_barometric_pressure) {
          Serial.print(F("Barometric Pressure: "));
          Serial.println(env_metrics->barometric_pressure);
        }

        if (env_metrics->has_gas_resistance) {
          Serial.print(F("Gas Resistance: "));
          Serial.println(env_metrics->gas_resistance);
        }

        if (env_metrics->has_voltage) {
          Serial.print(F("Voltage: "));
          Serial.println(env_metrics->voltage);
        }

        if (env_metrics->has_current) {
          Serial.print(F("Current: "));
          Serial.println(env_metrics->current);
        }

        if (env_metrics->has_iaq) {
          Serial.print(F("IAQ: "));
          Serial.println(env_metrics->iaq);
        }

        if (env_metrics->has_distance) {
          Serial.print(F("Distance: "));
          Serial.println(env_metrics->distance);
        }

        if (env_metrics->has_lux) {
          Serial.print(F("Ambient Light Lux: "));
          Serial.println(env_metrics->lux);
        }

        if (env_metrics->has_white_lux) {
          Serial.print(F("White Light Lux: "));
          Serial.println(env_metrics->white_lux);
        }

        if (env_metrics->has_ir_lux) {
          Serial.print(F("Infrared Lux: "));
          Serial.println(env_metrics->ir_lux);
        }

        if (env_metrics->has_uv_lux) {
          Serial.print(F("Ultraviolet Lux: "));
          Serial.println(env_metrics->uv_lux);
        }

        if (env_metrics->has_wind_direction) {
          Serial.print(F("Wind Direction: "));
          Serial.println(env_metrics->wind_direction);
        }

        if (env_metrics->has_wind_speed) {
          Serial.print(F("Wind Speed: "));
          Serial.println(env_metrics->wind_speed);
        }

        if (env_metrics->has_weight) {
          Serial.print(F("Weight: "));
          Serial.println(env_metrics->weight);
        }

        if (env_metrics->has_wind_gust) {
          Serial.print(F("Wind Gust: "));
          Serial.println(env_metrics->wind_gust);
        }

        if (env_metrics->has_wind_lull) {
          Serial.print(F("Wind Lull: "));
          Serial.println(env_metrics->wind_lull);
        }

        if (env_metrics->has_radiation) {
          Serial.print(F("Radiation: "));
          Serial.println(env_metrics->radiation);
        }

        if (env_metrics->has_rainfall_1h) {
          Serial.print(F("Rainfall (1h): "));
          Serial.println(env_metrics->rainfall_1h);
        }

        if (env_metrics->has_rainfall_24h) {
          Serial.print(F("Rainfall (24h): "));
          Serial.println(env_metrics->rainfall_24h);
        }
      }
    }
    Serial.println();
  }

  free(buf);
}

void loop() {}